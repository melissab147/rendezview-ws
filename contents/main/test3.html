<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>

	<body>
		<!-- <div id="container"></div> -->

		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/stats.min.js"></script>

		<script>

			//GLOBAL VARIABLES
			var container, stats;
			var camera, controls, scene, renderer;
			var cross;
			
			// set dimensions of area for visualization
			var WIDTH = document.getElementById('list').offsetWidth
			var HEADERHEIGHT = $(document.getElementById('header')).outerHeight(true)+3 //includes margins
			// console.log("header height ", HEADERHEIGHT2, HEADERHEIGHT1)
			var HEIGHT = window.innerHeight - HEADERHEIGHT //fills whole screen height beneath header	

			var camera2,
			    scene2,
			    renderer2,
			    axes2,
			    CANVAS_WIDTH = 100,
			    CANVAS_HEIGHT = 100,
			    CAM_DISTANCE = 300;

			init();
			animate();

			function init() {

				scene = new THREE.Scene();


				// CAMERA

				var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
				scene.add(camera);
				camera.position.set(0,700,1500);
				camera.lookAt(scene.position);	


				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize(WIDTH, HEIGHT);
				container = document.getElementById( 'list' );
				container.appendChild( renderer.domElement );


				// CONTROLS

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI/2;  //don't let camera go "underground"
				controls.userPanSpeed = 10

				// Add axes
				// axes = buildAxes( 1000 );
				// scene.add( axes );
				axes = new THREE.AxisHelper( 1000 );
				scene.add( axes );


				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = 100;
				// container.appendChild( stats.domElement );


				// LIGHT

				var light = new THREE.PointLight(0xaaaaaa);
				light.position.set(100,1000,100);
				scene.add(light);

				var light2 = new THREE.AmbientLight( 0x404040 );
				scene.add( light2 );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 3000, 10, 2000 );
				scene.add( directionalLight );

				var directionalLight2 = new THREE.DirectionalLight( 0x404040, 0.5 );
				directionalLight2.position.set( 3000, 10, -2000 );
				scene.add( directionalLight2 );


				// FLOOR
				var floorTexture = new THREE.ImageUtils.loadTexture( 'images/map-mirror.png' );
				floorTexture.wrapS = floorTexture.wrapT = THREE.ClampToEdgeWrapping; 
				var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
				var floorGeometry = new THREE.PlaneBufferGeometry(2000, 1237, 10, 10);
				var floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = -0.5;
				floor.rotation.x = Math.PI / 2;
				scene.add(floor);


				// SKYBOX
				var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBox);


				//// INSET AXES ////
				// CONTAINER
				container2 = document.getElementById('inset');

				// RENDERER
				renderer2 = new THREE.WebGLRenderer();
				renderer2.setClearColor( 0xf0f0f0, 1 );
				renderer2.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );
				container2.appendChild( renderer2.domElement );

				scene2 = new THREE.Scene();

				// CAMERA
				camera2 = new THREE.PerspectiveCamera( 50, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000 );
				camera2.up = camera.up; // important!

				// AXES
				axes2 = new THREE.AxisHelper( 100 );
				scene2.add( axes2 );


				//ADD BOXES

				addBox(100,200,100,0,0,'blue');
				addBox(100,100,100,200,200,'red');
				addBox(100,50,100,-200,200,'green');

				window.addEventListener( 'resize', onWindowResize, false );

				render();
			}

			function addBox(width, height, depth, xpos, ypos, color){

				var tpos = height/2

				var geometry = new THREE.BoxGeometry( width,height,depth); 
				var material =  new THREE.MeshLambertMaterial( { color: color} );
				var cube1 = new THREE.Mesh( geometry, material );
				cube1.position.set(xpos,tpos,ypos);	
				scene.add( cube1 );
			}

			function buildAxes( length ) {
				var axes = new THREE.Object3D();

				//vector()
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X west
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X east
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y up
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y down
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z north
				axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z south

				return axes;

			}

			function buildAxis( src, dst, colorHex, dashed ) {
				var geom = new THREE.Geometry(),
					mat; 

				if(dashed) {
					mat = new THREE.LineDashedMaterial({ linewidth: 100, color: colorHex, dashSize: 3, gapSize: 3 });
				} else {
					mat = new THREE.LineBasicMaterial({ linewidth: 10, color: colorHex });
				}

				geom.vertices.push( src.clone() );
				geom.vertices.push( dst.clone() );
				geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

				var axis = new THREE.Line( geom, mat, THREE.LinePieces );

				return axis;

			}

			// function onWindowResize() {

			// 	// camera.aspect = WIDTH / HEIGHT;
			// 	// camera.updateProjectionMatrix();
			// 	// renderer.setSize( WIDTH, HEIGHT );
			// 	// controls.handleResize(); //ERROR!!!///
			// 	// render();

			//     Width = container.clientWidth;
			//     Height = container.clientHeight;
			//     console.log(container,Width, Height)
			//     renderer.setSize(Width, Height);
			//     camera.aspect = Width / Height;
			//     camera.updateProjectionMatrix();
			//     controls.handleResize();				

			// }
			function onWindowResize(){

				var resizeWidth = document.getElementById('list').offsetWidth;
				var resizeHeight = window.innerHeight-HEADERHEIGHT;

			    camera.aspect = resizeWidth / window.innerHeight;
			    camera.updateProjectionMatrix();

			    renderer.setSize( resizeWidth, resizeHeight);

			}

			function animate() {

			    requestAnimationFrame( animate );
			    controls.update();

				camera2.position.copy( camera.position );
				// camera2.position.sub( controls.target ); // added by @libe
				// camera2.position.sub( camera.position, controls.target );
				camera2.position.sub( controls.center );
				camera2.position.setLength( CAM_DISTANCE );

			    camera2.lookAt( scene2.position );

				render();		
			}

			function render() {

				renderer.render( scene, camera );
				renderer2.render( scene2, camera2 );
				stats.update();
			}



		</script>

	</body>
</html>

<!-- https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/HelloWorld.html -->
