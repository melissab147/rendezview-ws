<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		  body {margin:1000;overflow:hidden;}
		  /*canvas {display:block;}*/
		</style> 		
	</head>

	<body>
		<!-- <div id="container"></div> -->

		<script src="fonts/helvetiker_regular.typeface.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/Detector.js"></script>		
		<script src="js/Projector.js"></script>


		<script>

			//GLOBAL VARIABLES
			var container, stats;
			var camera, controls, scene, renderer;
			var cross;
			
			// set dimensions of area for visualization
			var WIDTH = document.getElementById('lower').offsetWidth;
			// var leftOffset = window.innerWidth - WIDTH - document.getElementById("lower").style.paddingLeft;
			var leftOffset = window.innerWidth - WIDTH - parseInt(window.getComputedStyle(document.getElementById('page-content-wrapper'), null).getPropertyValue('padding-left'));
			// var HEADERHEIGHT = $(document.getElementById('header')).outerHeight(true)+3 //includes margins
			var HEADERHEIGHT = 	document.getElementById('upper').offsetHeight + 6 + 40; //fills whole screen height beneath header
			var HEIGHT = window.innerHeight - HEADERHEIGHT;
			var topOffset = parseInt(window.getComputedStyle(document.getElementById('page-content-wrapper'), null).getPropertyValue('padding-top'));
			// console.log(WIDTH, HEIGHT)
			console.log("leftOffset: "+leftOffset, " topOffset: "+topOffset);


			var camera2,
				scene2,
				renderer2,
				axes2,
				container2,
				xLabel,
				yLabel,
				time,
				CANVAS_WIDTH = 100,
				CANVAS_HEIGHT = 100,
				CAM_DISTANCE = 300;
			var tagCloudButton;
			var objects = [];            
			var projector;

			init();

			function init() {

				scene = new THREE.Scene();


				// CAMERA

				var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
				scene.add(camera);
				camera.position.set(0,1500,1500);
				camera.lookAt(scene.position);	


				// RENDERER
				if ( Detector.webgl )
					renderer = new THREE.WebGLRenderer( {antialias:true} );
				else
					renderer = new THREE.CanvasRenderer(); 
				// renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize(WIDTH, HEIGHT);
				container = document.getElementById( 'visualization' );
				container.appendChild( renderer.domElement );


				// CONTROLS

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI/2;  //don't let camera go "underground"
				controls.userPanSpeed = 10

				// Add axes
				axes = buildAxes( 1000 );
				scene.add( axes );
				// axes = new THREE.AxisHelper( 1000 );
				// scene.add( axes );


				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = 100;
				// container.appendChild( stats.domElement );


				// LIGHT

				var light = new THREE.PointLight(0xaaaaaa);
				light.position.set(100,1000,100);
				scene.add(light);

				var light2 = new THREE.AmbientLight( 0x404040 );
				scene.add( light2 );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 3000, 10, 2000 );
				scene.add( directionalLight );

				var directionalLight2 = new THREE.DirectionalLight( 0x404040, 0.5 );
				directionalLight2.position.set( 3000, 10, -2000 );
				scene.add( directionalLight2 );


				// FLOOR
				var floorTexture = new THREE.ImageUtils.loadTexture( 'images/map-mirror.png' );
				floorTexture.wrapS = floorTexture.wrapT = THREE.ClampToEdgeWrapping; 
				floorTexture.minFilter = THREE.NearestFilter;
				var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
				var floorGeometry = new THREE.PlaneBufferGeometry(2000, 1237, 10, 10);
				var floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = -0.5;
				floor.rotation.x = Math.PI / 2;
				scene.add(floor);


				// SKYBOX
				var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBox);


				//// INSET AXES ////
				// CONTAINER
				container2 = document.getElementById('inset-axes');

				// // STATIC TIME AXIS LABEL
				// var timeLabel = document.createElement("h5");
				// timeLabel.setAttribute("id", "time-label");
				// var node = document.createTextNode("TIME");
				// timeLabel.appendChild(node);
				// var element = document.getElementById("inset-axes");
				// element.appendChild(timeLabel);

				// RENDERER
				renderer2 = new THREE.WebGLRenderer({ alpha: true });
				// renderer2.setClearColor( 0xf0f0fs0, 1 );
				renderer2.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );
				container2.appendChild( renderer2.domElement );

				scene2 = new THREE.Scene();

				// CAMERA
				camera2 = new THREE.PerspectiveCamera( 50, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000 );
				camera2.up = camera.up; // important!

				// AXES
				axes2 = new THREE.AxisHelper( 100 );
				scene2.add( axes2 );

				// AXIS LABELS
				var shape = new THREE.TextGeometry("X", 
					{size: 20,
					 height: 0,
					 curveSegments: 3,
					 font: 'helvetiker',
					 weight: 'normal'
					});
				var wrapper = new THREE.MeshBasicMaterial({color: 0x000000});
				xLabel = new THREE.Mesh(shape, wrapper);
				xLabel.position.set(100,0,0);
				scene2.add(xLabel);

				var shape2 = new THREE.TextGeometry("Y", 
					{size: 20,
					 height: 0,
					 curveSegments: 10,
					 font: 'helvetiker',
					 weight: 'normal'
					});
				yLabel = new THREE.Mesh(shape2, wrapper);
				yLabel.position.set(0,0,100);	
				scene2.add(yLabel);

				var shape3 = new THREE.TextGeometry("TIME", 
					{size: 20,
					 height: 0,
					 curveSegments: 3,
					 font: 'helvetiker',
					 weight: 'normal'
					});
				time = new THREE.Mesh(shape3, wrapper);
				time.position.set(-25,100,0);	
				scene2.add(time);

				//// RESET VIEW ////
				var resetButton = document.createElement("a");
				resetButton.setAttribute("href", "#");
				resetButton.setAttribute("class", "btn btn-primary btn-sm");
				resetButton.setAttribute("id", "reset-button");	
				var resetSpan = document.createElement("span");
				resetSpan.setAttribute("class","glyphicon glyphicon-refresh");
				resetButton.appendChild(resetSpan);
				var node = document.createTextNode(" Reset View");
				resetButton.appendChild(node);
				document.getElementById('visualization').appendChild(resetButton);
				document.getElementById("reset-button").onclick = function() { 
					console.log("reset camera view");
					camera.position.set(0,1500,1500);
					controls.center.set(0,0,0);
					camera.lookAt(scene.position);
					// http://stackoverflow.com/questions/16525043/reset-camera-using-orbitcontrols-js
				}; 

				//// TAG CLOUD ////
				var tags = document.createElement("img");
				tags.setAttribute("src", "images/tag-cloud.png");
				tags.setAttribute("width", 300);
				tags.setAttribute("id", "tag-cloud");
				document.getElementById('visualization').appendChild(tags);

				// tagCloudButton = document.createElement("a");
				// tagCloudButton.setAttribute("href", "#");
				// tagCloudButton.setAttribute("class", "btn btn-primary btn-sm");
				// tagCloudButton.setAttribute("id", "tag-cloud-button");
				// tagCloudButton.style.right= resetButton.offsetWidth+"px";
				// var node = document.createTextNode(" Test Tag Cloud");
				// tagCloudButton.appendChild(node);
				// document.getElementById('visualization').appendChild(tagCloudButton);
				//Toggle tag cloud
				// tagCloudButton.addEventListener("click", toggleTagCloud, false);


				//// ADD BOXES ////

				addBox(100,200,100,0,0,'#4B3BFF');
				addBox(100,100,100,200,200,'#8175FF');
				addBox(100,50,100,-200,200,'#B6B0FF');

				window.addEventListener( 'resize', onWindowResize, false );

				animate();

			}

			// Make objects clickable
			var mouse = new THREE.Vector3(), INTERSECTED;
			raycaster = new THREE.Raycaster();
			container.addEventListener( 'click', onDocumentMouseMove, false );

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				// mouse.x = ( event.clientX / WIDTH ) * 2 - 1;
				// mouse.y = -( event.clientY / HEIGHT ) * 2 + 1;

				mouse.x = ( ( event.clientX - leftOffset) / WIDTH ) * 2 - 1; 
				mouse.y = - ( ( event.clientY - topOffset ) / HEIGHT ) * 2 + 1;

				mouse.z = 0.5;
				// find intersections
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				if( intersects.length > 0 ){// if an object was clicked
					var intersect = intersects[ 0 ];
					var newSelected = intersect.object;
					var color = newSelected.material.color.getHexString().toUpperCase();
					var originalColor = newSelected.name;
					var red = new THREE.Color( 0xFF0000 );

					// change color of box
					if(color != red.getHexString().toUpperCase()){
						console.log("change from "+color+" to red "+ red.getHexString().toUpperCase());
						newSelected.material.color.set( red );
						toggleTagCloud(1);
					}
					else{
						console.log("change from "+red.getHexString().toUpperCase()+" to original "+originalColor);
						newSelected.material.color.set( originalColor );
						toggleTagCloud(0);						
					}
					// newSelected.material.color.setHex( Math.random() * 0xffffff );

				}
				else{
					console.log('you clicked nothing');
				}


				// var mouse3D = new THREE.Vector3( ( event.clientX / WIDTH ) * 2 - 1,   //x
				//                                 -( event.clientY / HEIGHT ) * 2 + 1,  //y
				//                                 0.5 );                                            //z
				// projector.unprojectVector( mouse3D, camera );  
				// // vector.unproject(mouse3D,camera); 
				// mouse3D.sub( camera.position );                
				// mouse3D.normalize();
				// var raycaster = new THREE.Raycaster( camera.position, mouse3D );
				// var intersects = raycaster.intersectObjects( objects );
				// // Change color if hit block
				// if ( intersects.length > 0 ) {
				// 	console.log(intersects[ 0 ].object.name);
				//     intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
				// }
				// render();

			}


			function addBox( width, height, depth, xpos, ypos, color ){

				var tpos = height/2;

				var geometry = new THREE.BoxGeometry( width,height,depth); 
				var material =  new THREE.MeshLambertMaterial( { color: color} );
				var cube = new THREE.Mesh( geometry, material );
				cube.position.set(xpos,tpos,ypos);
				cube.name = color;

				// var outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xFFFF00, side: THREE.BackSide } );
				// var outlineMesh1 = new THREE.Mesh( geometry, outlineMaterial1 );
				// outlineMesh1.position.set(xpos,tpos,ypos);
				// outlineMesh1.scale.multiplyScalar(1.05);
				// scene.add( outlineMesh1 );				

				scene.add( cube );
				objects.push( cube );
				console.log(cube.name)

			}

			function buildAxes( length ) {
				var axes = new THREE.Object3D();

				//vector()
				axes.add( buildAxis( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X west
				// axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X east
				axes.add( buildAxis( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y up
				// axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y down
				axes.add( buildAxis( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z north
				// axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z south

				return axes;

			}

			function buildAxis( src, dst, colorHex, dashed ) {
				var geom = new THREE.Geometry(),
					mat; 

				if(dashed) {
					mat = new THREE.LineDashedMaterial({ linewidth: 100, color: colorHex, dashSize: 3, gapSize: 3 });
				} else {
					mat = new THREE.LineBasicMaterial({ linewidth: 10, color: colorHex });
				}

				geom.vertices.push( src.clone() );
				geom.vertices.push( dst.clone() );
				geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

				var axis = new THREE.Line( geom, mat, THREE.LinePieces );

				return axis;

			}

			function toggleTagCloud(onOff) { 
				var e = document.getElementById("tag-cloud");

				if(onOff == 1){
					e.style.display = 'block';
					// document.getElementById("tag-cloud-button").className += " active";					
				}
				else{
					e.style.display = 'none';
					// tagCloudButton.setAttribute("class", "btn btn-primary btn-sm");					
				}

				// if(e.style.display == 'block'){
				// 	e.style.display = 'none';
				// 	tagCloudButton.setAttribute("class", "btn btn-primary btn-sm");
				// }
				// else{
				// 	e.style.display = 'block';
				// 	document.getElementById("tag-cloud-button").className += " active";
				// }
			}; 

			function onWindowResize(){

				// Recompute renderer dimensions
				WIDTH = document.getElementById('visualization').offsetWidth;
				HEIGHT = window.innerHeight - HEADERHEIGHT;

				// Recompute offsets of renderer for clicking objects
				leftOffset = window.innerWidth - WIDTH - parseInt(window.getComputedStyle(document.getElementById('page-content-wrapper'), null).getPropertyValue('padding-left'));
				topOffset = parseInt(window.getComputedStyle(document.getElementById('page-content-wrapper'), null).getPropertyValue('padding-top'));
				console.log("Resized: leftOffset: "+leftOffset, " topOffset: "+topOffset);

				// Update camera and renderer
				camera.aspect = WIDTH / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( WIDTH, HEIGHT);

				//https://github.com/mrdoob/three.js/issues/69

			}

			function animate() {

				requestAnimationFrame( animate );
				controls.update();

				camera2.position.copy( camera.position );
				// camera2.position.sub( controls.target ); // added by @libe
				// camera2.position.sub( camera.position, controls.target );
				camera2.position.sub( controls.center );
				camera2.position.setLength( CAM_DISTANCE );

				camera2.lookAt( scene2.position );

				render();
			}

			function render() {

				renderer.render( scene, camera );
				renderer2.render( scene2, camera2 );
				// if ( timeLabel ) //billboarding: always have label face camera
					// timeLabel.lookAt( camera.position );
				xLabel.quaternion.copy( camera.quaternion );
				yLabel.quaternion.copy( camera.quaternion );
				time.quaternion.copy( camera.quaternion );
				stats.update();
			}

		</script>

	</body>
</html>

<!-- https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/HelloWorld.html -->
